!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Barebones algorithm to help the development of miniapps
module adjoint_test_alg_mod

  use constants_mod,                  only: i_def,r_def
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W2
  use function_space_collection_mod,  only: function_space_collection
  use operator_mod,                   only: operator_type
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type

  implicit none

  private

  public :: adjoint_test_alg

contains

  !> @details An algorithm for developing miniapps
  !> @param[inout] field_1  A prognostic field object
  subroutine adjoint_test_alg(field_0, chi, panel_id)

    use field_mod, only : field_type
    use function_space_mod, only : function_space_type
    use fs_continuity_mod, only : w0, w1, w2, w3
    use constants_mod, only : i_def, r_def
    use operator_mod, only : operator_type
    use tl_vorticity_advection_kernel_mod, only : tl_vorticity_advection_kernel_type
    use tl_vorticity_advection_kernel_mod_adj, only : tl_vorticity_advection_kernel_type_adj
    use quadrature_xyoz_mod, only : quadrature_xyoz_type
    use quadrature_rule_gaussian_mod, only : quadrature_rule_gaussian_type
    implicit none
    ! Prognostic fields
    type( field_type ), intent( inout ) :: field_0
    type( field_type ), dimension(3), intent( in ) :: chi
    type(field_type), intent(in)                   :: panel_id


  real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
  type(mesh_type), pointer :: mesh => null()
  TYPE(function_space_type), POINTER :: vector_space_w1_ptr
  !TYPE(function_space_type), TARGET :: vector_space_w0
  TYPE(function_space_type), POINTER :: vector_space_w0_ptr
  !TYPE(function_space_type), TARGET :: vector_space_w2
  TYPE(function_space_type), POINTER :: vector_space_w2_ptr
  !TYPE(function_space_type), TARGET :: vector_space_w3
  TYPE(function_space_type), POINTER :: vector_space_w3_ptr
  type(field_type) :: field_1
  type(field_type) :: field_2
  type(field_type) :: field_3
  type(field_type) :: field_4
  type(field_type) :: field_5
  type(field_type), dimension(3) :: field_6
  type(field_type) :: field_7
  type(quadrature_xyoz_type) :: qr_xyoz
  type(quadrature_rule_gaussian_type) :: quadrature_rule
  type(field_type) :: field_1_input
  type(field_type) :: field_2_input
  type(field_type) :: field_3_input
  type(field_type) :: field_4_input
  type(field_type) :: field_5_input
  real(kind=r_def) :: field_1_inner_prod
  real(kind=r_def) :: field_2_inner_prod
  real(kind=r_def) :: field_3_inner_prod
  real(kind=r_def) :: field_4_inner_prod
  real(kind=r_def) :: field_5_inner_prod
  real(kind=r_def), dimension(3) :: field_6_inner_prod
  real(kind=r_def) :: field_7_inner_prod
  real(kind=r_def) :: inner1
  real(kind=r_def) :: inner2
  real(kind=r_def) :: MachineTol
  real(kind=r_def) :: relative_diff

  mesh => field_0%get_mesh()

  !vector_space_w1 = function_space_type(mesh,element_order,w1,ndata_sz)
  vector_space_w1_ptr => function_space_collection%get_fs( mesh, element_order, W1)
  !vector_space_w0 = function_space_type(mesh,element_order,w0,ndata_sz)
  vector_space_w0_ptr => function_space_collection%get_fs( mesh, element_order, W0)
  !vector_space_w2 = function_space_type(mesh,element_order,w2,ndata_sz)
  vector_space_w2_ptr => function_space_collection%get_fs( mesh, element_order, W2)
  !vector_space_w3 = function_space_type(mesh,element_order,w3,ndata_sz)
  vector_space_w3_ptr => function_space_collection%get_fs( mesh, element_order, W3)
  call field_1 % initialise(vector_space=vector_space_w2_ptr, name='field_1')
  call field_2 % initialise(vector_space=vector_space_w2_ptr, name='field_2')
  call field_3 % initialise(vector_space=vector_space_w1_ptr, name='field_3')
  call field_4 % initialise(vector_space=vector_space_w2_ptr, name='field_4')
  call field_5 % initialise(vector_space=vector_space_w1_ptr, name='field_5')
  call field_6(1) % initialise(vector_space=vector_space_w0_ptr, name='field_6')
  call field_6(2) % initialise(vector_space=vector_space_w0_ptr, name='field_6')
  call field_6(3) % initialise(vector_space=vector_space_w0_ptr, name='field_6')
  call field_7 % initialise(vector_space=vector_space_w3_ptr, name='field_7')
  qr_xyoz = quadrature_xyoz_type(element_order + 3,quadrature_rule)
  call field_1_input % initialise(vector_space=vector_space_w2_ptr, name='field_1_input')
  call field_2_input % initialise(vector_space=vector_space_w2_ptr, name='field_2_input')
  call field_3_input % initialise(vector_space=vector_space_w1_ptr, name='field_3_input')
  call field_4_input % initialise(vector_space=vector_space_w2_ptr, name='field_4_input')
  call field_5_input % initialise(vector_space=vector_space_w1_ptr, name='field_5_input')
  call field_6_input(1) % initialise(vector_space=vector_space_w0_ptr, name='field_6_input')
  call field_6_input(2) % initialise(vector_space=vector_space_w0_ptr, name='field_6_input')
  call field_6_input(3) % initialise(vector_space=vector_space_w0_ptr, name='field_6_input')
  call field_7_input % initialise(vector_space=vector_space_w3_ptr, name='field_7_input')
  field_1_inner_prod = 0.0_r_def
  field_2_inner_prod = 0.0_r_def
  field_3_inner_prod = 0.0_r_def
  field_4_inner_prod = 0.0_r_def
  field_5_inner_prod = 0.0_r_def
  field_6_inner_prod(1) = 0.0_r_def
  field_6_inner_prod(2) = 0.0_r_def
  field_6_inner_prod(3) = 0.0_r_def
  field_7_inner_prod = 0.0_r_def
  call invoke(setval_random(field_1), setval_x(field_1_input, field_1), &
       setval_random(field_2), setval_x(field_2_input, field_2), &
       setval_random(field_3), setval_x(field_3_input, field_3), &
       setval_random(field_4), setval_x(field_4_input, field_4), &
       setval_random(field_5), setval_x(field_5_input, field_5), &
       setval_random(field_6(1)), setval_x(field_6_input(1), field_6(1)), &
       setval_random(field_6(2)), setval_x(field_6_input(2), field_6(2)), &
       setval_random(field_6(3)), setval_x(field_6_input(3), field_6(3)), &
       setval_random(field_7), setval_x(field_7_input, panel_id), &
       tl_vorticity_advection_kernel_type(field_1, field_2, field_3, field_4, &
       field_5, chi, panel_id, qr_xyoz), &
       x_innerproduct_x(field_1_inner_prod, field_1), &
       x_innerproduct_x(field_2_inner_prod, field_2), &
       x_innerproduct_x(field_3_inner_prod, field_3), &
       x_innerproduct_x(field_4_inner_prod, field_4), &
       x_innerproduct_x(field_5_inner_prod, field_5))
  inner1 = 0.0_r_def
  inner1 = inner1 + field_1_inner_prod
  inner1 = inner1 + field_2_inner_prod
  inner1 = inner1 + field_3_inner_prod
  inner1 = inner1 + field_4_inner_prod
  inner1 = inner1 + field_5_inner_prod
  inner1 = inner1 + field_6_inner_prod(1)
  inner1 = inner1 + field_6_inner_prod(2)
  inner1 = inner1 + field_6_inner_prod(3)
  inner1 = inner1 + field_7_inner_prod
  field_1_inner_prod = 0.0_r_def
  field_2_inner_prod = 0.0_r_def
  field_3_inner_prod = 0.0_r_def
  field_4_inner_prod = 0.0_r_def
  field_5_inner_prod = 0.0_r_def
  field_6_inner_prod(1) = 0.0_r_def
  field_6_inner_prod(2) = 0.0_r_def
  field_6_inner_prod(3) = 0.0_r_def
  field_7_inner_prod = 0.0_r_def
  
  call invoke(tl_vorticity_advection_kernel_type_adj(field_1, field_2, &
       field_3, field_4, field_5, chi, panel_id, qr_xyoz), &
       x_innerproduct_y(field_1_inner_prod, field_1, field_1_input), &
       x_innerproduct_y(field_2_inner_prod, field_2, field_2_input), &
       x_innerproduct_y(field_3_inner_prod, field_3, field_3_input), &
       x_innerproduct_y(field_4_inner_prod, field_4, field_4_input), &
       x_innerproduct_y(field_5_inner_prod, field_5, field_5_input))
  inner2 = 0.0_r_def
  inner2 = inner2 + field_1_inner_prod
  inner2 = inner2 + field_2_inner_prod
  inner2 = inner2 + field_3_inner_prod
  inner2 = inner2 + field_4_inner_prod
  inner2 = inner2 + field_5_inner_prod
  inner2 = inner2 + field_6_inner_prod(1)
  inner2 = inner2 + field_6_inner_prod(2)
  inner2 = inner2 + field_6_inner_prod(3)
  inner2 = inner2 + field_7_inner_prod
  ! Test the inner-product values for equality, allowing for the precision of the active variables
  MachineTol = SPACING(MAX(ABS(inner1), ABS(inner2)))
  relative_diff = ABS(inner1 - inner2) / MachineTol
  if (relative_diff < overall_tolerance) then
     WRITE(*, *) 'Test of adjoint of ''tl_vorticity_advection_kernel_type'' PASSED: ', &
          inner1, inner2, relative_diff
  else
     WRITE(*, *) 'Test of adjoint of ''tl_vorticity_advection_kernel_type'' FAILED: ', &
          inner1, inner2, relative_diff
  end if

    ! Diagnostic fields
    !type( field_type )                  :: field_2

    !real(r_def)                         :: s
    !type( operator_type ), pointer      :: divergence => null()

    !call log_event( "adjoint_test: Running algorithm", LOG_LEVEL_INFO )

    ! Create a new field on the W2 function space
    !call field_2%initialise( function_space_collection%get_fs( mesh, element_order, W2))

    ! Set the new field to a constant value and compute the divergence of it
    !divergence => get_div()
    !s = 2.0_r_def
    !call invoke( name = "Compute divergence",  &
    !             setval_c(field_2, s        ), &
    !             setval_c(field_1, 0.0_r_def), &
    !             matrix_vector_kernel_type(field_1, field_2, divergence) )

    ! The divergence of a constant field should be zero so lets check this by
    ! printing the min/max values in field_1
    !call field_1%log_minmax(LOG_LEVEL_INFO,'field_1')

    nullify(mesh)

    call log_event( "adjoint_test: finished algorithm", LOG_LEVEL_INFO )

  end subroutine adjoint_test_alg

end module adjoint_test_alg_mod
